//We set up the coordinate ring of the canonical component of the character variety

G<g,h>:=FreeGroup(2);

// for convenience, we define gi, hi to be the inverse element. This is because G is already
gi:=g^-1;
hi:=h^-1;


charVarTwoGenGroup:=function(word) //takes as input a word in the free group <g,h>. This is assumed to be the single relation of a 2-bridge knot group, where the generators g,h are conjugate. The function returns a reduced affine curve (potentially in multiple components) that is the closure in the character variety of the variety of (absolutely) irreducible characters.
    freeGroup:=Parent(word);
    GroundField := Rationals();
    ring := PolynomialRing(GroundField,4);
    temp_f<x,r,q,w> := FieldOfFractions(ring);
    rhog := Matrix([[x, 1], [0, x^(-1)]]);
    rhoh := Matrix([[x, 0], [r, x^(-1)]]);
    GM:=GModule(freeGroup, [rhog,rhoh]); // we assume our group is generated by two elements, and that
    // we are investigating irreducible SL(2) representations of this group.
  
    v1:=elt<GM|1,0>;
    v2:=elt<GM|0,1>;

    relationMatrix :=  Matrix([Eltseq(v1*word),Eltseq(v2*word)]) - ScalarMatrix(ring,2,1);
    // we assume 'word' is the unique relation. This translates to one matrix in x,r that must be 0.
    polys := {};
    for i in {1,2} do
	for j in {1,2} do
	    if relationMatrix[i,j] ne 0 then
		Include(~polys,ring ! Numerator(relationMatrix[i,j])); // need all relations to hold (i.e. entries to be zero)
	    end if;
	end for;
    end for;
    eigenvalue_variety := GCD(polys); // this is the simplest condition enforcing the relation. 
    //    assert IsPrime(eigenvalue_variety); // This need not be the case in general. It is the case in small examples, which is all this code handles for now.
    intermediate1 := Resultant(eigenvalue_variety, ring ! (x^4+x^2*r+1 - w*x^2), 2); // We enforce the relation that wx^2 = x^4+ x^2r + 1, and use it to eliminate r.
    intermediate2 := Resultant(intermediate1, ring ! (x^2 + 1 - q*x), 1); // enforcing q = x+x^-1, to eliminate x.
    factors,char_var := Factorization(intermediate2);
    for poly in factors do
	if poly[2] ge 1 then
	    char_var := char_var * poly[1]; // getting rid of multiplicities
	end if;
    end for;
    //    assert IsPrime(char_var); // this is not generically true, but we hope it is in our case
    ring_2<s,t> := PolynomialRing(GroundField,2); // for some type conversion trickery
    conv_map := hom<ring -> ring_2 | 0, 0, s, t>;
    aff_spc := AffineSpace(ring_2);
    can_comp<q,w> := Scheme(aff_spc,conv_map(char_var)); // assumes char_var is in GF<q,w>
    return can_comp;
end function;

tautologicalQuaternionAlgebra:=function(variety) // takes a character variety of the sort produced by charVarTwoGenGroup, assumed irreducible, and returns the tautological quaternion algebra over the fraction field (i.e., at the generic point)
    ff<I_g,I_gh> := FieldOfFractions(CoordinateRing(variety));
    QA := QuaternionAlgebra<ff | I_g^2-4, -(I_g^2-4)*(I_g^2-4)+(2*I_gh-I_g*I_g)^2>;
    return QA;
end function;

